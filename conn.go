package xws

import (
	"net"
	"net/http"
	"sync"
	"time"
)

type (
	// Socket is the interface that an underline protocol implementation should implement.
	Socket interface {
		// NetConn returns the underline net connection.
		NetConn() net.Conn
		// Request returns the http request value.
		Request() *http.Request
		// ReadData reads binary or text messages from the remote connection.
		ReadData(timeout time.Duration) (body []byte, typ MessageType, err error)
		// WriteBinary sends a binary message to the remote connection.
		WriteBinary(body []byte, timeout time.Duration) error
		// WriteText sends a text message to the remote connection.
		WriteText(body []byte, timeout time.Duration) error
	}

	// MessageType is a type for readen and to-send data, helpful to set `msg.SetBinary`
	// to the rest of the clients through a Broadcast, as SetBinary is not part of the deserialization.
	MessageType uint8
)

// See `MessageType` definition for details.
const (
	TextMessage = iota + 1
	BinaryMessage
)

type Conn struct {
	// the ID generated by `Server#IDGenerator`.
	id string
	// serverConnID is unique per server instance and it can be comparable only within the
	// same server instance. Even if Server#IDGenerator
	// returns the same ID from the request.
	serverConnID string
	// a context-scope storage, initialized on first `Set`.
	store      map[string]interface{}
	storeMutex sync.RWMutex

	// the gorilla or gobwas socket.
	socket Socket

	// non-nil if server-side connection.
	server *Server

	// maximum wait time allowed to read a message from the connection.
	// Defaults to no timeout.
	readTimeout time.Duration
	// maximum wait time allowed to write a message to the connection.
	// Defaults to no timeout.
	writeTimeout time.Duration

	// more than 0 if acknowledged.
	acknowledged *uint32

	queue      map[MessageType][][]byte
	queueMutex sync.Mutex

	// used to fire `conn#Close` once.
	closed *uint32
	// useful to terminate the broadcaster, see `Server#ServeHTTP.waitMessages`.
	closeCh chan struct{}
}

func newConn(socket Socket) *Conn {
	c := &Conn{
		socket:                         socket,
		acknowledged:                   new(uint32),
		closed:                         new(uint32),
		closeCh:                        make(chan struct{}),
	}

	return c
}

